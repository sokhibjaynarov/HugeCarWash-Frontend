{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Pipe, EventEmitter, forwardRef, TemplateRef, Component, ViewEncapsulation, ViewChild, Input, Output, ContentChild, NgModule } from '@angular/core';\nimport { fromEvent } from 'rxjs';\nimport { map, filter, debounceTime } from 'rxjs/operators';\nimport * as i2 from '@angular/forms';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nconst _c0 = [\"searchInput\"];\nconst _c1 = [\"filteredListElement\"];\nconst _c2 = [\"historyListElement\"];\n\nfunction AutocompleteComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 14);\n    i0.ɵɵlistener(\"click\", function AutocompleteComponent_div_4_Template_div_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.remove($event);\n    });\n    i0.ɵɵelementStart(1, \"i\", 15);\n    i0.ɵɵtext(2, \"close\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction AutocompleteComponent_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 16);\n    i0.ɵɵelement(1, \"div\", 17);\n    i0.ɵɵelement(2, \"div\", 18);\n    i0.ɵɵelement(3, \"div\", 19);\n    i0.ɵɵelement(4, \"div\", 20);\n    i0.ɵɵelement(5, \"div\", 21);\n    i0.ɵɵelement(6, \"div\", 22);\n    i0.ɵɵelement(7, \"div\", 23);\n    i0.ɵɵelement(8, \"div\", 24);\n    i0.ɵɵelement(9, \"div\", 25);\n    i0.ɵɵelement(10, \"div\", 26);\n    i0.ɵɵelement(11, \"div\", 27);\n    i0.ɵɵelement(12, \"div\", 28);\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction AutocompleteComponent_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 29);\n    i0.ɵɵelementStart(1, \"div\", 30);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r3.heading);\n  }\n}\n\nfunction AutocompleteComponent_li_10_div_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c3 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\n\nfunction AutocompleteComponent_li_10_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 33);\n    i0.ɵɵlistener(\"click\", function AutocompleteComponent_li_10_div_1_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const item_r13 = i0.ɵɵnextContext().$implicit;\n      const ctx_r18 = i0.ɵɵnextContext();\n      return ctx_r18.select(item_r13);\n    });\n    i0.ɵɵtemplate(1, AutocompleteComponent_li_10_div_1_ng_container_1_Template, 1, 0, \"ng-container\", 34);\n    i0.ɵɵpipe(2, \"highlight\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext();\n    const idx_r14 = ctx_r21.index;\n    const item_r13 = ctx_r21.$implicit;\n    const ctx_r15 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"complete-selected\", idx_r14 === ctx_r15.selectedIdx);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r15.itemTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(7, _c3, i0.ɵɵpipeBind2(2, 4, item_r13, ctx_r15.toHighlight)));\n  }\n}\n\nfunction AutocompleteComponent_li_10_div_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction AutocompleteComponent_li_10_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r25 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 33);\n    i0.ɵɵlistener(\"click\", function AutocompleteComponent_li_10_div_2_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r25);\n      const item_r13 = i0.ɵɵnextContext().$implicit;\n      const ctx_r23 = i0.ɵɵnextContext();\n      return ctx_r23.select(item_r13);\n    });\n    i0.ɵɵtemplate(1, AutocompleteComponent_li_10_div_2_ng_container_1_Template, 1, 0, \"ng-container\", 34);\n    i0.ɵɵpipe(2, \"highlight\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r26 = i0.ɵɵnextContext();\n    const idx_r14 = ctx_r26.index;\n    const item_r13 = ctx_r26.$implicit;\n    const ctx_r16 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"complete-selected\", idx_r14 === ctx_r16.selectedIdx);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r16.itemTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(8, _c3, i0.ɵɵpipeBind3(2, 4, item_r13, ctx_r16.toHighlight, ctx_r16.searchKeyword)));\n  }\n}\n\nfunction AutocompleteComponent_li_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 31);\n    i0.ɵɵtemplate(1, AutocompleteComponent_li_10_div_1_Template, 3, 9, \"div\", 32);\n    i0.ɵɵtemplate(2, AutocompleteComponent_li_10_div_2_Template, 3, 10, \"div\", 32);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r13 = ctx.$implicit;\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.isTypeString(item_r13));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.isTypeString(item_r13));\n  }\n}\n\nfunction AutocompleteComponent_div_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r28 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 29);\n    i0.ɵɵelementStart(1, \"div\", 30);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"div\", 14);\n    i0.ɵɵlistener(\"click\", function AutocompleteComponent_div_12_Template_div_click_3_listener($event) {\n      i0.ɵɵrestoreView(_r28);\n      const ctx_r27 = i0.ɵɵnextContext();\n      return ctx_r27.resetHistoryList($event);\n    });\n    i0.ɵɵelementStart(4, \"i\", 35);\n    i0.ɵɵtext(5, \"delete\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r6.historyHeading);\n  }\n}\n\nfunction AutocompleteComponent_li_15_div_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction AutocompleteComponent_li_15_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r36 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 33);\n    i0.ɵɵlistener(\"click\", function AutocompleteComponent_li_15_div_1_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r36);\n      const item_r29 = i0.ɵɵnextContext().$implicit;\n      const ctx_r34 = i0.ɵɵnextContext();\n      return ctx_r34.select(item_r29);\n    });\n    i0.ɵɵtemplate(1, AutocompleteComponent_li_15_div_1_ng_container_1_Template, 1, 0, \"ng-container\", 34);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r37 = i0.ɵɵnextContext();\n    const idx_r30 = ctx_r37.index;\n    const item_r29 = ctx_r37.$implicit;\n    const ctx_r31 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"complete-selected\", idx_r30 === ctx_r31.selectedIdx);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r31.itemTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(4, _c3, item_r29));\n  }\n}\n\nfunction AutocompleteComponent_li_15_div_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction AutocompleteComponent_li_15_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r41 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 33);\n    i0.ɵɵlistener(\"click\", function AutocompleteComponent_li_15_div_2_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r41);\n      const item_r29 = i0.ɵɵnextContext().$implicit;\n      const ctx_r39 = i0.ɵɵnextContext();\n      return ctx_r39.select(item_r29);\n    });\n    i0.ɵɵtemplate(1, AutocompleteComponent_li_15_div_2_ng_container_1_Template, 1, 0, \"ng-container\", 34);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r42 = i0.ɵɵnextContext();\n    const idx_r30 = ctx_r42.index;\n    const item_r29 = ctx_r42.$implicit;\n    const ctx_r32 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"complete-selected\", idx_r30 === ctx_r32.selectedIdx);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r32.itemTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(4, _c3, item_r29));\n  }\n}\n\nfunction AutocompleteComponent_li_15_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r44 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"li\", 31);\n    i0.ɵɵtemplate(1, AutocompleteComponent_li_15_div_1_Template, 2, 6, \"div\", 32);\n    i0.ɵɵtemplate(2, AutocompleteComponent_li_15_div_2_Template, 2, 6, \"div\", 32);\n    i0.ɵɵelementStart(3, \"div\", 14);\n    i0.ɵɵlistener(\"click\", function AutocompleteComponent_li_15_Template_div_click_3_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r44);\n      const idx_r30 = restoredCtx.index;\n      const ctx_r43 = i0.ɵɵnextContext();\n      return ctx_r43.removeHistoryItem(idx_r30, $event);\n    });\n    i0.ɵɵelementStart(4, \"i\", 15);\n    i0.ɵɵtext(5, \"close\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r29 = ctx.$implicit;\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r8.isTypeString(item_r29));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r8.isTypeString(item_r29));\n  }\n}\n\nfunction AutocompleteComponent_div_16_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction AutocompleteComponent_div_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 36);\n    i0.ɵɵtemplate(1, AutocompleteComponent_div_16_ng_container_1_Template, 1, 0, \"ng-container\", 34);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r9.notFoundTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c3, ctx_r9.notFoundText));\n  }\n}\n\nfunction AutocompleteComponent_div_17_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r47 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 37);\n    i0.ɵɵlistener(\"click\", function AutocompleteComponent_div_17_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r47);\n      const ctx_r46 = i0.ɵɵnextContext();\n      return ctx_r46.handleOverlay();\n    });\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c4 = function (a0) {\n  return {\n    \"active\": a0\n  };\n};\n\nconst _c5 = function (a0, a1) {\n  return {\n    \"is-hidden\": a0,\n    \"is-visible\": a1\n  };\n};\n\nlet HighlightPipe = /*#__PURE__*/(() => {\n  class HighlightPipe {\n    transform(text, search, searchKeyword) {\n      let pattern = search.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n      pattern = pattern.split(' ').filter(t => {\n        return t.length > 0;\n      }).join('|');\n      const regex = new RegExp(pattern, 'gi');\n\n      if (!search) {\n        return text;\n      }\n\n      if (searchKeyword) {\n        const name = text[searchKeyword].replace(regex, match => `<b>${match}</b>`); // copy original object\n\n        const textCopied = Object.assign({}, text); // set bold value into searchKeyword of copied object\n\n        textCopied[searchKeyword] = name;\n        return textCopied;\n      } else {\n        return search ? text.replace(regex, match => `<b>${match}</b>`) : text;\n      }\n    }\n\n  }\n\n  HighlightPipe.ɵfac = function HighlightPipe_Factory(t) {\n    return new (t || HighlightPipe)();\n  };\n\n  HighlightPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"highlight\",\n    type: HighlightPipe,\n    pure: true\n  });\n  return HighlightPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Keyboard events\n */\n\n\nconst isArrowUp = keyCode => keyCode === 38;\n\nconst isArrowDown = keyCode => keyCode === 40;\n\nconst isArrowUpDown = keyCode => isArrowUp(keyCode) || isArrowDown(keyCode);\n\nconst isEnter = keyCode => keyCode === 13;\n\nconst isBackspace = keyCode => keyCode === 8;\n\nconst isDelete = keyCode => keyCode === 46;\n\nconst isESC = keyCode => keyCode === 27;\n\nconst isTab = keyCode => keyCode === 9;\n\nlet AutocompleteComponent = /*#__PURE__*/(() => {\n  class AutocompleteComponent {\n    constructor(elementRef, renderer) {\n      this.renderer = renderer;\n      this.query = ''; // search query\n\n      this.filteredList = []; // list of items\n\n      this.historyList = []; // list of history items\n\n      this.isHistoryListVisible = true;\n      this.selectedIdx = -1;\n      this.toHighlight = '';\n      this.notFound = false;\n      this.isFocused = false;\n      this.isOpen = false;\n      this.isScrollToEnd = false;\n      this.overlay = false;\n      this.manualOpen = undefined;\n      this.manualClose = undefined; // @Inputs\n\n      /**\n       * Data of items list.\n       * It can be array of strings or array of objects.\n       */\n\n      this.data = [];\n      this.placeholder = '';\n      this.heading = '';\n      /**\n       * Heading text of history list.\n       * If it is null then history heading is hidden.\n       */\n\n      this.historyHeading = 'Recently selected';\n      this.historyListMaxNumber = 15; // maximum number of items in the history list.\n\n      this.notFoundText = 'Not found'; // set custom text when filter returns empty result\n\n      /**\n       * The minimum number of characters the user must type before a search is performed.\n       */\n\n      this.minQueryLength = 1;\n      /**\n       * Focus first item in the list\n       */\n\n      this.focusFirst = false; // @Output events\n\n      /** Event that is emitted whenever an item from the list is selected. */\n\n      this.selected = new EventEmitter();\n      /** Event that is emitted whenever an input is changed. */\n\n      this.inputChanged = new EventEmitter();\n      /** Event that is emitted whenever an input is focused. */\n\n      this.inputFocused = new EventEmitter();\n      /** Event that is emitted whenever an input is cleared. */\n\n      this.inputCleared = new EventEmitter();\n      /** Event that is emitted when the autocomplete panel is opened. */\n\n      this.opened = new EventEmitter();\n      /** Event that is emitted when the autocomplete panel is closed. */\n\n      this.closed = new EventEmitter();\n      /** Event that is emitted when scrolled to the end of items. */\n\n      this.scrolledToEnd = new EventEmitter();\n      /**\n       * Propagates new value when model changes\n       */\n\n      this.propagateChange = () => {};\n\n      this.onTouched = () => {};\n\n      this.elementRef = elementRef;\n    }\n    /**\n     * Writes a new value from the form model into the view,\n     * Updates model\n     */\n\n\n    writeValue(value = '') {\n      this.query = this.selectedValueRender !== undefined ? this.selectedValueRender(value) : this.defaultWriteValue(value);\n    }\n\n    defaultWriteValue(value) {\n      return value && !this.isTypeString(value) ? value[this.searchKeyword] : value;\n    }\n    /**\n     * Registers a handler that is called when something in the view has changed\n     */\n\n\n    registerOnChange(fn) {\n      this.propagateChange = fn;\n    }\n    /**\n     * Registers a handler specifically for when a control receives a touch event\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /**\n     * Event that is called when the value of an input element is changed\n     */\n\n\n    onChange(event) {\n      this.propagateChange(event.target.value);\n    }\n    /**\n     * Event that is called when the control status changes to or from DISABLED\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n\n    ngOnInit() {}\n\n    ngAfterViewInit() {\n      this.initEventStream();\n      this.handleScroll();\n    }\n    /**\n     * Set initial value\n     * @param value\n     */\n\n\n    setInitialValue(value) {\n      if (this.initialValue) {\n        this.select(value);\n      }\n    }\n    /**\n     * Update search results\n     */\n\n\n    ngOnChanges(changes) {\n      this.setInitialValue(this.initialValue);\n\n      if (changes && changes.data && Array.isArray(changes.data.currentValue)) {\n        this.handleItemsChange();\n\n        if (!changes.data.firstChange && this.isFocused) {\n          this.handleOpen();\n        }\n      }\n    }\n    /**\n     * Items change\n     */\n\n\n    handleItemsChange() {\n      this.isScrollToEnd = false;\n\n      if (!this.isOpen) {\n        return;\n      }\n\n      this.filteredList = this.data;\n      this.notFound = !this.filteredList || this.filteredList.length === 0; // Filter list when updating data and panel is open\n\n      if (this.isOpen) {\n        this.filterList();\n      }\n    }\n    /**\n     * Filter data\n     */\n\n\n    filterList() {\n      this.selectedIdx = -1;\n      this.initSearchHistory();\n\n      if (this.query != null && this.data) {\n        this.toHighlight = this.query;\n        this.filteredList = this.customFilter !== undefined ? this.customFilter([...this.data], this.query) : this.defaultFilterFunction(); // If [focusFirst]=\"true\" automatically focus the first match\n\n        if (this.filteredList.length > 0 && this.focusFirst) {\n          this.selectedIdx = 0;\n        }\n      } else {\n        this.notFound = false;\n      }\n    }\n    /**\n     * Default filter function, used unless customFilter is provided\n     */\n\n\n    defaultFilterFunction() {\n      return this.data.filter(item => {\n        if (typeof item === 'string') {\n          // string logic, check equality of strings\n          return item.toLowerCase().indexOf(this.query.toLowerCase()) > -1;\n        } else if (typeof item === 'object' && item instanceof Object) {\n          // object logic, check property equality\n          return item[this.searchKeyword] ? item[this.searchKeyword].toLowerCase().indexOf(this.query.toLowerCase()) > -1 : \"\";\n        }\n      });\n    }\n    /**\n     * Check if item is a string in the list.\n     * @param item\n     */\n\n\n    isTypeString(item) {\n      return typeof item === 'string';\n    }\n    /**\n     * Select item in the list.\n     * @param item\n     */\n\n\n    select(item) {\n      this.query = !this.isTypeString(item) ? item[this.searchKeyword] : item;\n      this.isOpen = true;\n      this.overlay = false;\n      this.selected.emit(item);\n      this.propagateChange(item);\n\n      if (this.initialValue) {\n        // check if history already exists in localStorage and then update\n        const history = window.localStorage.getItem(`${this.historyIdentifier}`);\n\n        if (history) {\n          let existingHistory = JSON.parse(localStorage[`${this.historyIdentifier}`]);\n          if (!(existingHistory instanceof Array)) existingHistory = []; // check if selected item exists in existingHistory\n\n          if (!existingHistory.some(existingItem => !this.isTypeString(existingItem) ? existingItem[this.searchKeyword] == item[this.searchKeyword] : existingItem == item)) {\n            existingHistory.unshift(item);\n            localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(existingHistory)); // check if items don't exceed max allowed number\n\n            if (existingHistory.length >= this.historyListMaxNumber) {\n              existingHistory.splice(existingHistory.length - 1, 1);\n              localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(existingHistory));\n            }\n          } else {\n            // if selected item exists in existingHistory swap to top in array\n            if (!this.isTypeString(item)) {\n              // object logic\n              const copiedExistingHistory = existingHistory.slice(); // copy original existingHistory array\n\n              const selectedIndex = copiedExistingHistory.map(el => el[this.searchKeyword]).indexOf(item[this.searchKeyword]);\n              copiedExistingHistory.splice(selectedIndex, 1);\n              copiedExistingHistory.splice(0, 0, item);\n              localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(copiedExistingHistory));\n            } else {\n              // string logic\n              const copiedExistingHistory = existingHistory.slice(); // copy original existingHistory array\n\n              copiedExistingHistory.splice(copiedExistingHistory.indexOf(item), 1);\n              copiedExistingHistory.splice(0, 0, item);\n              localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(copiedExistingHistory));\n            }\n          }\n        } else {\n          this.saveHistory(item);\n        }\n      } else {\n        this.saveHistory(item);\n      }\n\n      this.handleClose();\n    }\n    /**\n     * Document click\n     * @param e event\n     */\n\n\n    handleClick(e) {\n      let clickedComponent = e.target;\n      let inside = false;\n\n      do {\n        if (clickedComponent === this.elementRef.nativeElement) {\n          inside = true;\n\n          if (this.filteredList.length) {\n            this.handleOpen();\n          }\n        }\n\n        clickedComponent = clickedComponent.parentNode;\n      } while (clickedComponent);\n\n      if (!inside) {\n        this.handleClose();\n      }\n    }\n    /**\n     * Handle body overlay\n     */\n\n\n    handleOverlay() {\n      this.overlay = false;\n    }\n    /**\n     * Scroll items\n     */\n\n\n    handleScroll() {\n      this.renderer.listen(this.filteredListElement.nativeElement, 'scroll', () => {\n        this.scrollToEnd();\n      });\n    }\n    /**\n     * Define panel state\n     */\n\n\n    setPanelState(event) {\n      if (event) {\n        event.stopPropagation();\n      } // If controls are untouched\n\n\n      if (typeof this.manualOpen === 'undefined' && typeof this.manualClose === 'undefined') {\n        this.isOpen = false;\n        this.handleOpen();\n      } // If one of the controls is untouched and other is deactivated\n\n\n      if (typeof this.manualOpen === 'undefined' && this.manualClose === false || typeof this.manualClose === 'undefined' && this.manualOpen === false) {\n        this.isOpen = false;\n        this.handleOpen();\n      } // if controls are touched but both are deactivated\n\n\n      if (this.manualOpen === false && this.manualClose === false) {\n        this.isOpen = false;\n        this.handleOpen();\n      } // if open control is touched and activated\n\n\n      if (this.manualOpen) {\n        this.isOpen = false;\n        this.handleOpen();\n        this.manualOpen = false;\n      } // if close control is touched and activated\n\n\n      if (this.manualClose) {\n        this.isOpen = true;\n        this.handleClose();\n        this.manualClose = false;\n      }\n    }\n    /**\n     * Manual controls\n     */\n\n\n    open() {\n      this.manualOpen = true;\n      this.isOpen = false;\n      this.handleOpen();\n    }\n\n    close() {\n      this.manualClose = true;\n      this.isOpen = true;\n      this.handleClose();\n    }\n\n    focus() {\n      this.handleFocus(event);\n    }\n\n    clear() {\n      this.remove(event);\n    }\n    /**\n     * Remove search query\n     */\n\n\n    remove(e) {\n      e.stopPropagation();\n      this.query = '';\n      this.inputCleared.emit();\n      this.propagateChange(this.query);\n      this.setPanelState(e);\n\n      if (this.data && !this.data.length) {\n        this.notFound = false;\n      }\n    }\n    /**\n     * Initialize historyList search\n     */\n\n\n    initSearchHistory() {\n      this.isHistoryListVisible = false;\n\n      if (this.historyIdentifier && !this.query) {\n        const history = window.localStorage.getItem(`${this.historyIdentifier}`);\n\n        if (history) {\n          this.isHistoryListVisible = true;\n          this.filteredList = [];\n          this.historyList = history ? JSON.parse(history) : [];\n        } else {\n          this.isHistoryListVisible = false;\n        }\n      } else {\n        this.isHistoryListVisible = false;\n      }\n    }\n\n    handleOpen() {\n      if (this.isOpen || this.isOpen && !this.isLoading) {\n        return;\n      } // If data exists\n\n\n      if (this.data && this.data.length) {\n        this.isOpen = true;\n        this.overlay = true;\n        this.filterList();\n        this.opened.emit();\n      }\n    }\n\n    handleClose() {\n      if (!this.isOpen) {\n        this.isFocused = false;\n        return;\n      }\n\n      this.isOpen = false;\n      this.overlay = false;\n      this.filteredList = [];\n      this.selectedIdx = -1;\n      this.notFound = false;\n      this.isHistoryListVisible = false;\n      this.isFocused = false;\n      this.closed.emit();\n    }\n\n    handleFocus(e) {\n      this.searchInput.nativeElement.focus();\n\n      if (this.isFocused) {\n        return;\n      }\n\n      this.inputFocused.emit(e); // if data exists then open\n\n      if (this.data && this.data.length) {\n        this.setPanelState(e);\n      }\n\n      this.isFocused = true;\n    }\n\n    scrollToEnd() {\n      if (this.isScrollToEnd) {\n        return;\n      }\n\n      const scrollTop = this.filteredListElement.nativeElement.scrollTop;\n      const scrollHeight = this.filteredListElement.nativeElement.scrollHeight;\n      const elementHeight = this.filteredListElement.nativeElement.clientHeight;\n      const atBottom = elementHeight != 0 && Math.abs(scrollHeight - elementHeight - scrollTop) < 1;\n\n      if (atBottom) {\n        this.scrolledToEnd.emit();\n        this.isScrollToEnd = true;\n      }\n    }\n    /**\n     * Initialize keyboard events\n     */\n\n\n    initEventStream() {\n      this.inputKeyUp$ = fromEvent(this.searchInput.nativeElement, 'keyup').pipe(map(e => e));\n      this.inputKeyDown$ = fromEvent(this.searchInput.nativeElement, 'keydown').pipe(map(e => e));\n      this.listenEventStream();\n    }\n    /**\n     * Listen keyboard events\n     */\n\n\n    listenEventStream() {\n      // key up event\n      this.inputKeyUp$.pipe(filter(e => !isArrowUpDown(e.keyCode) && !isEnter(e.keyCode) && !isESC(e.keyCode) && !isTab(e.keyCode)), debounceTime(this.debounceTime)).subscribe(e => {\n        this.onKeyUp(e);\n      }); // cursor up & down\n\n      this.inputKeyDown$.pipe(filter(e => isArrowUpDown(e.keyCode))).subscribe(e => {\n        e.preventDefault();\n        this.onFocusItem(e);\n      }); // enter keyup\n\n      this.inputKeyUp$.pipe(filter(e => isEnter(e.keyCode))).subscribe(e => {//this.onHandleEnter();\n      }); // enter keydown\n\n      this.inputKeyDown$.pipe(filter(e => isEnter(e.keyCode))).subscribe(e => {\n        this.onHandleEnter();\n      }); // ESC\n\n      this.inputKeyUp$.pipe(filter(e => isESC(e.keyCode), debounceTime(100))).subscribe(e => {\n        this.onEsc();\n      }); // TAB\n\n      this.inputKeyDown$.pipe(filter(e => isTab(e.keyCode))).subscribe(e => {\n        this.onTab();\n      }); // delete\n\n      this.inputKeyDown$.pipe(filter(e => isBackspace(e.keyCode) || isDelete(e.keyCode))).subscribe(e => {\n        this.onDelete();\n      });\n    }\n    /**\n     * on keyup == when input changed\n     * @param e event\n     */\n\n\n    onKeyUp(e) {\n      this.notFound = false; // search results are unknown while typing\n      // if input is empty\n\n      if (!this.query) {\n        this.notFound = false;\n        this.inputChanged.emit(e.target.value);\n        this.inputCleared.emit();\n        this.setPanelState(e);\n      } // note that '' can be a valid query\n\n\n      if (!this.query && this.query !== '') {\n        return;\n      } // if query >= to minQueryLength\n\n\n      if (this.query.length >= this.minQueryLength) {\n        this.inputChanged.emit(e.target.value);\n        this.filterList(); // If no results found\n\n        if (!this.filteredList.length && !this.isLoading) {\n          this.notFoundText ? this.notFound = true : this.notFound = false;\n        }\n\n        if (this.data && !this.data.length) {\n          this.isOpen = true;\n        }\n      }\n    }\n    /**\n     * Keyboard arrow top and arrow bottom\n     * @param e event\n     */\n\n\n    onFocusItem(e) {\n      // move arrow up and down on filteredList or historyList\n      if (!this.historyList.length || !this.isHistoryListVisible) {\n        // filteredList\n        const totalNumItem = this.filteredList.length;\n\n        if (e.key === 'ArrowDown') {\n          let sum = this.selectedIdx;\n          sum = this.selectedIdx === null ? 0 : sum + 1;\n          this.selectedIdx = (totalNumItem + sum) % totalNumItem;\n          this.scrollToFocusedItem(this.selectedIdx);\n        } else if (e.key === 'ArrowUp') {\n          if (this.selectedIdx == -1) {\n            this.selectedIdx = 0;\n          }\n\n          this.selectedIdx = (totalNumItem + this.selectedIdx - 1) % totalNumItem;\n          this.scrollToFocusedItem(this.selectedIdx);\n        }\n      } else {\n        // historyList\n        const totalNumItem = this.historyList.length;\n\n        if (e.key === 'ArrowDown') {\n          let sum = this.selectedIdx;\n          sum = this.selectedIdx === null ? 0 : sum + 1;\n          this.selectedIdx = (totalNumItem + sum) % totalNumItem;\n          this.scrollToFocusedItem(this.selectedIdx);\n        } else if (e.key === 'ArrowUp') {\n          if (this.selectedIdx == -1) {\n            this.selectedIdx = 0;\n          }\n\n          this.selectedIdx = (totalNumItem + this.selectedIdx - 1) % totalNumItem;\n          this.scrollToFocusedItem(this.selectedIdx);\n        }\n      }\n    }\n    /**\n     * Scroll to focused item\n     * * @param index\n     */\n\n\n    scrollToFocusedItem(index) {\n      let listElement = null; // Define list element\n\n      if (!this.historyList.length || !this.isHistoryListVisible) {\n        // filteredList element\n        listElement = this.filteredListElement.nativeElement;\n      } else {\n        // historyList element\n        listElement = this.historyListElement.nativeElement;\n      }\n\n      const items = Array.prototype.slice.call(listElement.childNodes).filter(node => {\n        if (node.nodeType === 1) {\n          // if node is element\n          return node.className.includes('item');\n        } else {\n          return false;\n        }\n      });\n\n      if (!items.length) {\n        return;\n      }\n\n      const listHeight = listElement.offsetHeight;\n      const itemHeight = items[index].offsetHeight;\n      const visibleTop = listElement.scrollTop;\n      const visibleBottom = listElement.scrollTop + listHeight - itemHeight;\n      const targetPosition = items[index].offsetTop;\n\n      if (targetPosition < visibleTop) {\n        listElement.scrollTop = targetPosition;\n      }\n\n      if (targetPosition > visibleBottom) {\n        listElement.scrollTop = targetPosition - listHeight + itemHeight;\n      }\n    }\n    /**\n     * Select item on enter click\n     */\n\n\n    onHandleEnter() {\n      // click enter to choose item from filteredList or historyList\n      if (this.selectedIdx > -1) {\n        if (!this.historyList.length || !this.isHistoryListVisible) {\n          // filteredList\n          this.query = !this.isTypeString(this.filteredList[this.selectedIdx]) ? this.filteredList[this.selectedIdx][this.searchKeyword] : this.filteredList[this.selectedIdx];\n          this.saveHistory(this.filteredList[this.selectedIdx]);\n          this.select(this.filteredList[this.selectedIdx]);\n        } else {\n          // historyList\n          this.query = !this.isTypeString(this.historyList[this.selectedIdx]) ? this.historyList[this.selectedIdx][this.searchKeyword] : this.historyList[this.selectedIdx];\n          this.saveHistory(this.historyList[this.selectedIdx]);\n          this.select(this.historyList[this.selectedIdx]);\n        }\n      }\n\n      this.isHistoryListVisible = false;\n      this.handleClose();\n    }\n    /**\n     * Esc click\n     */\n\n\n    onEsc() {\n      this.searchInput.nativeElement.blur();\n      this.handleClose();\n    }\n    /**\n     * Tab click\n     */\n\n\n    onTab() {\n      this.searchInput.nativeElement.blur();\n      this.handleClose();\n    }\n    /**\n     * Delete click\n     */\n\n\n    onDelete() {\n      this.isOpen = true;\n    }\n    /**\n     * Select item to save in localStorage\n     * @param selected\n     */\n\n\n    saveHistory(selected) {\n      if (this.historyIdentifier) {\n        // check if selected item exists in historyList\n        if (!this.historyList.some(item => !this.isTypeString(item) ? item[this.searchKeyword] == selected[this.searchKeyword] : item == selected)) {\n          this.saveHistoryToLocalStorage([selected, ...this.historyList]); // check if items don't exceed max allowed number\n\n          if (this.historyList.length >= this.historyListMaxNumber) {\n            this.historyList.splice(this.historyList.length - 1, 1);\n            this.saveHistoryToLocalStorage([selected, ...this.historyList]);\n          }\n        } else {\n          // if selected item exists in historyList swap to top in array\n          if (!this.isTypeString(selected)) {\n            // object logic\n            const copiedHistoryList = this.historyList.slice(); // copy original historyList array\n\n            const selectedIndex = copiedHistoryList.map(item => item[this.searchKeyword]).indexOf(selected[this.searchKeyword]);\n            copiedHistoryList.splice(selectedIndex, 1);\n            copiedHistoryList.splice(0, 0, selected);\n            this.saveHistoryToLocalStorage([...copiedHistoryList]);\n          } else {\n            // string logic\n            const copiedHistoryList = this.historyList.slice(); // copy original historyList array\n\n            copiedHistoryList.splice(this.historyList.indexOf(selected), 1);\n            copiedHistoryList.splice(0, 0, selected);\n            this.saveHistoryToLocalStorage([...copiedHistoryList]);\n          }\n        }\n      }\n    }\n    /**\n     * Save item in localStorage\n     * @param selected\n     */\n\n\n    saveHistoryToLocalStorage(selected) {\n      window.localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(selected));\n    }\n    /**\n     * Remove item from localStorage\n     * @param index\n     * @param e event\n     */\n\n\n    removeHistoryItem(index, e) {\n      e.stopPropagation();\n      this.historyList = this.historyList.filter((v, i) => i !== index);\n      this.saveHistoryToLocalStorage(this.historyList);\n\n      if (this.historyList.length == 0) {\n        window.localStorage.removeItem(`${this.historyIdentifier}`);\n        this.filterList();\n      }\n    }\n    /**\n     * Reset localStorage\n     * @param e event\n     */\n\n\n    resetHistoryList(e) {\n      e.stopPropagation();\n      this.historyList = [];\n      window.localStorage.removeItem(`${this.historyIdentifier}`);\n      this.filterList();\n    }\n\n  }\n\n  AutocompleteComponent.ɵfac = function AutocompleteComponent_Factory(t) {\n    return new (t || AutocompleteComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  AutocompleteComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: AutocompleteComponent,\n    selectors: [[\"ng-autocomplete\"]],\n    contentQueries: function AutocompleteComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.customTemplate = _t.first);\n      }\n    },\n    viewQuery: function AutocompleteComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n        i0.ɵɵviewQuery(_c1, 5);\n        i0.ɵɵviewQuery(_c2, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.searchInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filteredListElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.historyListElement = _t.first);\n      }\n    },\n    hostAttrs: [1, \"ng-autocomplete\"],\n    hostBindings: function AutocompleteComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function AutocompleteComponent_click_HostBindingHandler($event) {\n          return ctx.handleClick($event);\n        }, false, i0.ɵɵresolveDocument);\n      }\n    },\n    inputs: {\n      data: \"data\",\n      searchKeyword: \"searchKeyword\",\n      placeholder: \"placeholder\",\n      heading: \"heading\",\n      initialValue: \"initialValue\",\n      historyIdentifier: \"historyIdentifier\",\n      historyHeading: \"historyHeading\",\n      historyListMaxNumber: \"historyListMaxNumber\",\n      notFoundText: \"notFoundText\",\n      isLoading: \"isLoading\",\n      debounceTime: \"debounceTime\",\n      disabled: \"disabled\",\n      minQueryLength: \"minQueryLength\",\n      focusFirst: \"focusFirst\",\n      customFilter: \"customFilter\",\n      selectedValueRender: \"selectedValueRender\",\n      itemTemplate: \"itemTemplate\",\n      notFoundTemplate: \"notFoundTemplate\"\n    },\n    outputs: {\n      selected: \"selected\",\n      inputChanged: \"inputChanged\",\n      inputFocused: \"inputFocused\",\n      inputCleared: \"inputCleared\",\n      opened: \"opened\",\n      closed: \"closed\",\n      scrolledToEnd: \"scrolledToEnd\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => AutocompleteComponent),\n      multi: true\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 18,\n    vars: 24,\n    consts: [[\"aria-owns\", \"suggestions suggestions-history\", 1, \"autocomplete-container\", 3, \"ngClass\"], [1, \"input-container\"], [\"type\", \"text\", \"aria-autocomplete\", \"list\", \"role\", \"combobox\", \"autocomplete\", \"off\", 3, \"placeholder\", \"ngModel\", \"disabled\", \"ngModelChange\", \"input\", \"focus\", \"blur\"], [\"searchInput\", \"\"], [\"class\", \"x\", 3, \"click\", 4, \"ngIf\"], [\"class\", \"sk-fading-circle\", 4, \"ngIf\"], [\"id\", \"suggestions\", \"role\", \"listbox\", 1, \"suggestions-container\", 3, \"ngClass\"], [\"class\", \"heading\", 4, \"ngIf\"], [\"filteredListElement\", \"\"], [\"class\", \"item\", 4, \"ngFor\", \"ngForOf\"], [\"id\", \"suggestions-history\", \"role\", \"listbox\", 1, \"suggestions-container\", 3, \"ngClass\"], [\"historyListElement\", \"\"], [\"class\", \"not-found\", 4, \"ngIf\"], [\"class\", \"autocomplete-overlay\", 3, \"click\", 4, \"ngIf\"], [1, \"x\", 3, \"click\"], [\"aria-label\", \"Close\", 1, \"material-icons\"], [1, \"sk-fading-circle\"], [1, \"sk-circle1\", \"sk-circle\"], [1, \"sk-circle2\", \"sk-circle\"], [1, \"sk-circle3\", \"sk-circle\"], [1, \"sk-circle4\", \"sk-circle\"], [1, \"sk-circle5\", \"sk-circle\"], [1, \"sk-circle6\", \"sk-circle\"], [1, \"sk-circle7\", \"sk-circle\"], [1, \"sk-circle8\", \"sk-circle\"], [1, \"sk-circle9\", \"sk-circle\"], [1, \"sk-circle10\", \"sk-circle\"], [1, \"sk-circle11\", \"sk-circle\"], [1, \"sk-circle12\", \"sk-circle\"], [1, \"heading\"], [1, \"text\"], [1, \"item\"], [3, \"complete-selected\", \"click\", 4, \"ngIf\"], [3, \"click\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"aria-label\", \"Delete\", 1, \"material-icons\"], [1, \"not-found\"], [1, \"autocomplete-overlay\", 3, \"click\"]],\n    template: function AutocompleteComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵelementStart(2, \"input\", 2, 3);\n        i0.ɵɵlistener(\"ngModelChange\", function AutocompleteComponent_Template_input_ngModelChange_2_listener($event) {\n          return ctx.query = $event;\n        })(\"input\", function AutocompleteComponent_Template_input_input_2_listener($event) {\n          return ctx.onChange($event);\n        })(\"focus\", function AutocompleteComponent_Template_input_focus_2_listener($event) {\n          return ctx.handleFocus($event);\n        })(\"blur\", function AutocompleteComponent_Template_input_blur_2_listener($event) {\n          return ctx.onTouched($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(4, AutocompleteComponent_div_4_Template, 3, 0, \"div\", 4);\n        i0.ɵɵtemplate(5, AutocompleteComponent_div_5_Template, 13, 0, \"div\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"div\", 6);\n        i0.ɵɵtemplate(7, AutocompleteComponent_div_7_Template, 3, 1, \"div\", 7);\n        i0.ɵɵelementStart(8, \"ul\", null, 8);\n        i0.ɵɵtemplate(10, AutocompleteComponent_li_10_Template, 3, 2, \"li\", 9);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(11, \"div\", 10);\n        i0.ɵɵtemplate(12, AutocompleteComponent_div_12_Template, 6, 1, \"div\", 7);\n        i0.ɵɵelementStart(13, \"ul\", null, 11);\n        i0.ɵɵtemplate(15, AutocompleteComponent_li_15_Template, 6, 2, \"li\", 9);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(16, AutocompleteComponent_div_16_Template, 2, 4, \"div\", 12);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(17, AutocompleteComponent_div_17_Template, 1, 0, \"div\", 13);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(16, _c4, ctx.isOpen));\n        i0.ɵɵattribute(\"aria-expanded\", ctx.isOpen);\n        i0.ɵɵadvance(2);\n        i0.ɵɵpropertyInterpolate(\"placeholder\", ctx.placeholder);\n        i0.ɵɵproperty(\"ngModel\", ctx.query)(\"disabled\", ctx.disabled);\n        i0.ɵɵattribute(\"aria-label\", ctx.placeholder);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.query && !ctx.isLoading && !ctx.disabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isLoading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(18, _c5, ctx.isHistoryListVisible, !ctx.isHistoryListVisible));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.filteredList.length > 0 && ctx.heading);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngForOf\", ctx.filteredList);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(21, _c5, !ctx.isHistoryListVisible, ctx.isHistoryListVisible));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.historyList.length > 0 && ctx.historyHeading);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngForOf\", ctx.historyList);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isLoading ? !ctx.isLoading && ctx.notFound : ctx.notFound);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.overlay);\n      }\n    },\n    directives: [i1.NgClass, i2.DefaultValueAccessor, i2.NgControlStatus, i2.NgModel, i1.NgIf, i1.NgForOf, i1.NgTemplateOutlet],\n    pipes: [HighlightPipe],\n    styles: [\"@import\\\"https://fonts.googleapis.com/icon?family=Material+Icons\\\";.ng-autocomplete{width:600px}.autocomplete-container{box-shadow:0 1px 3px #0003,0 1px 1px #00000024,0 2px 1px -1px #0000001f;position:relative;overflow:visible;height:40px}.autocomplete-container .input-container input{font-size:14px;box-sizing:border-box;border:none;box-shadow:none;outline:none;background-color:#fff;color:#000000de;width:100%;padding:0 15px;line-height:40px;height:40px}.autocomplete-container .input-container input:disabled{background-color:#eee;color:#666}.autocomplete-container .input-container .x{position:absolute;right:10px;margin:auto;cursor:pointer;top:50%;transform:translateY(-50%)}.autocomplete-container .input-container .x i{color:#0000008a;font-size:22px;vertical-align:middle}.autocomplete-container .suggestions-container{position:absolute;width:100%;background:white;height:auto;box-shadow:0 2px 5px #00000040;box-sizing:border-box}.autocomplete-container .suggestions-container ul{padding:0;margin:0;max-height:240px;overflow-y:auto}.autocomplete-container .suggestions-container ul li{position:relative;list-style:none;padding:0;margin:0;cursor:pointer}.autocomplete-container .suggestions-container ul li a{padding:14px 15px;display:block;text-decoration:none;color:#333;cursor:pointer;color:#000000de;font-size:15px}.autocomplete-container .suggestions-container ul li:hover,.autocomplete-container .suggestions-container .complete-selected{background-color:#9e9e9e2e}.autocomplete-container .suggestions-container .heading{position:relative;padding:10px 15px;border:solid 1px #f1f1f1}.autocomplete-container .suggestions-container .heading .text{font-size:.85em}.autocomplete-container .suggestions-container .x{position:absolute;right:10px;margin:auto;cursor:pointer;top:50%;transform:translateY(-50%)}.autocomplete-container .suggestions-container .x i{color:#0000008a;font-size:18px;vertical-align:middle}.autocomplete-container .suggestions-container.is-hidden{visibility:hidden}.autocomplete-container .suggestions-container.is-visible{visibility:visible}.autocomplete-container .not-found{padding:0 .75em;border:solid 1px #f1f1f1;background:white}.autocomplete-container .not-found div{padding:.4em 0;font-size:.95em;line-height:1.4;border-bottom:1px solid rgba(230,230,230,.7)}.autocomplete-container.active{z-index:999}.highlight{font-weight:700}.autocomplete-overlay{position:fixed;background-color:transparent;width:100%;height:100%;top:0;right:0;bottom:0;left:0;z-index:50}input[type=text]::-ms-clear{display:none}.sk-fading-circle{width:20px;height:20px;position:absolute;right:10px;top:0;bottom:0;margin:auto}.sk-fading-circle .sk-circle{width:100%;height:100%;position:absolute;left:0;top:0}.sk-fading-circle .sk-circle:before{content:\\\"\\\";display:block;margin:0 auto;width:15%;height:15%;background-color:#333;border-radius:100%;animation:sk-circleFadeDelay 1.2s infinite ease-in-out both}.sk-fading-circle .sk-circle2{transform:rotate(30deg)}.sk-fading-circle .sk-circle3{transform:rotate(60deg)}.sk-fading-circle .sk-circle4{transform:rotate(90deg)}.sk-fading-circle .sk-circle5{transform:rotate(120deg)}.sk-fading-circle .sk-circle6{transform:rotate(150deg)}.sk-fading-circle .sk-circle7{transform:rotate(180deg)}.sk-fading-circle .sk-circle8{transform:rotate(210deg)}.sk-fading-circle .sk-circle9{transform:rotate(240deg)}.sk-fading-circle .sk-circle10{transform:rotate(270deg)}.sk-fading-circle .sk-circle11{transform:rotate(300deg)}.sk-fading-circle .sk-circle12{transform:rotate(330deg)}.sk-fading-circle .sk-circle2:before{animation-delay:-1.1s}.sk-fading-circle .sk-circle3:before{animation-delay:-1s}.sk-fading-circle .sk-circle4:before{animation-delay:-.9s}.sk-fading-circle .sk-circle5:before{animation-delay:-.8s}.sk-fading-circle .sk-circle6:before{animation-delay:-.7s}.sk-fading-circle .sk-circle7:before{animation-delay:-.6s}.sk-fading-circle .sk-circle8:before{animation-delay:-.5s}.sk-fading-circle .sk-circle9:before{animation-delay:-.4s}.sk-fading-circle .sk-circle10:before{animation-delay:-.3s}.sk-fading-circle .sk-circle11:before{animation-delay:-.2s}.sk-fading-circle .sk-circle12:before{animation-delay:-.1s}@keyframes sk-circleFadeDelay{0%,39%,to{opacity:0}40%{opacity:1}}\\n\"],\n    encapsulation: 2\n  });\n  return AutocompleteComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AutocompleteLibModule = /*#__PURE__*/(() => {\n  class AutocompleteLibModule {}\n\n  AutocompleteLibModule.ɵfac = function AutocompleteLibModule_Factory(t) {\n    return new (t || AutocompleteLibModule)();\n  };\n\n  AutocompleteLibModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AutocompleteLibModule\n  });\n  AutocompleteLibModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule]]\n  });\n  return AutocompleteLibModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of autocomplete-lib\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AutocompleteComponent, AutocompleteLibModule, HighlightPipe }; //# sourceMappingURL=angular-ng-autocomplete.mjs.map","map":null,"metadata":{},"sourceType":"module"}